"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/use-audio.tsx":
/*!*****************************!*\
  !*** ./hooks/use-audio.tsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAudio: () => (/* binding */ useAudio)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_@babel+core@7.2_b45306ac393cb74e69a281713883807c/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* __next_internal_client_entry_do_not_use__ useAudio auto */ var _s = $RefreshSig$();\n\nfunction useAudio(src) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    _s();\n    const [audio, setAudio] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [isReady, setIsReady] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false) // New state for readiness\n    ;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAudio.useEffect\": ()=>{\n            // Only create audio element in browser environment\n            if (true) {\n                const audioElement = new Audio();\n                console.log(\"useAudio: Creating new Audio element for \".concat(src));\n                audioElement.preload = \"auto\"; // Hint to the browser to load the audio\n                // Set properties before setting src to avoid issues\n                if (options.volume !== undefined) {\n                    // Clamp volume between 0 and 1\n                    audioElement.volume = Math.max(0, Math.min(1, options.volume));\n                }\n                if (options.loop !== undefined) {\n                    audioElement.loop = options.loop;\n                }\n                // Event Handlers\n                const handleError = {\n                    \"useAudio.useEffect.handleError\": (e)=>{\n                        console.warn(\"useAudio: Audio error for \".concat(src), e);\n                        setIsReady(false); // Audio is not ready if an error occurs\n                    }\n                }[\"useAudio.useEffect.handleError\"];\n                const handleCanPlayThrough = {\n                    \"useAudio.useEffect.handleCanPlayThrough\": ()=>{\n                        console.log(\"useAudio: Audio for \".concat(src, \" can play through.\"));\n                        setIsReady(true);\n                    }\n                }[\"useAudio.useEffect.handleCanPlayThrough\"];\n                const handlePlaying = {\n                    \"useAudio.useEffect.handlePlaying\": ()=>{\n                        setIsPlaying(true);\n                    }\n                }[\"useAudio.useEffect.handlePlaying\"];\n                const handlePause = {\n                    \"useAudio.useEffect.handlePause\": ()=>{\n                        setIsPlaying(false);\n                    }\n                }[\"useAudio.useEffect.handlePause\"];\n                const handleEnded = {\n                    \"useAudio.useEffect.handleEnded\": ()=>{\n                        if (!audioElement.loop) {\n                            setIsPlaying(false);\n                        }\n                    }\n                }[\"useAudio.useEffect.handleEnded\"];\n                audioElement.addEventListener(\"error\", handleError);\n                audioElement.addEventListener(\"canplaythrough\", handleCanPlayThrough);\n                audioElement.addEventListener(\"playing\", handlePlaying);\n                audioElement.addEventListener(\"pause\", handlePause);\n                audioElement.addEventListener(\"ended\", handleEnded);\n                audioElement.src = src // Set source last\n                ;\n                setAudio(audioElement) // This will trigger re-render where hook is used\n                ;\n                return ({\n                    \"useAudio.useEffect\": ()=>{\n                        console.log(\"useAudio: Cleaning up Audio element for \".concat(src));\n                        audioElement.pause();\n                        audioElement.removeEventListener(\"error\", handleError);\n                        audioElement.removeEventListener(\"canplaythrough\", handleCanPlayThrough);\n                        audioElement.removeEventListener(\"playing\", handlePlaying);\n                        audioElement.removeEventListener(\"pause\", handlePause);\n                        audioElement.removeEventListener(\"ended\", handleEnded);\n                        audioElement.src = \"\" // Release the resource\n                        ;\n                        setAudio(null) // Clear the audio element from state\n                        ;\n                        setIsReady(false) // Reset readiness state\n                        ;\n                        setIsPlaying(false) // Reset playing state\n                        ;\n                    }\n                })[\"useAudio.useEffect\"];\n            }\n            return undefined // For server-side or if window is undefined\n            ;\n        }\n    }[\"useAudio.useEffect\"], [\n        src,\n        options.volume,\n        options.loop\n    ]) // options.autoplay handled in another effect\n    ;\n    // Autoplay effect - will attempt to play if options.autoplay is true AND audio is ready\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAudio.useEffect\": ()=>{\n            if (audio && isReady && options.autoplay && !isPlaying) {\n                console.log(\"useAudio: Autoplay triggered for \".concat(src));\n                audio.play().catch({\n                    \"useAudio.useEffect\": (error)=>{\n                        // This catch is for autoplay attempts within the hook\n                        console.warn(\"useAudio: Autoplay for \".concat(src, \" failed. Browser policy likely prevented it.\"), error);\n                    }\n                }[\"useAudio.useEffect\"]);\n            }\n        }\n    }[\"useAudio.useEffect\"], [\n        audio,\n        isReady,\n        options.autoplay,\n        isPlaying\n    ]); // Removed play from here, direct audio.play()\n    const play = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAudio.useCallback[play]\": async ()=>{\n            if (audio && audio.paused) {\n                console.log(\"useAudio: play() called by component\");\n                try {\n                    await audio.play();\n                // isPlaying state will be updated by the 'playing' event listener\n                } catch (error) {\n                    console.warn(\"useAudio: Error in play() caught:\", error);\n                    // isPlaying state should be handled by 'pause' or 'error' listeners if play fails\n                    throw error; // Re-throw so the calling component can also catch it\n                }\n            } else if (audio && !audio.paused) {\n                console.log(\"useAudio: play() called, but audio already playing.\");\n                return Promise.resolve(); // Indicate success as it's already playing\n            } else {\n                console.warn(\"useAudio: play() called, but audio element is not available or ready.\");\n                return Promise.reject(new Error(\"Audio element not available or not ready.\"));\n            }\n        }\n    }[\"useAudio.useCallback[play]\"], [\n        audio\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAudio.useCallback[pause]\": ()=>{\n            if (audio) {\n                audio.pause();\n            // isPlaying state will be updated by the 'pause' event listener\n            }\n        }\n    }[\"useAudio.useCallback[pause]\"], [\n        audio\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAudio.useCallback[stop]\": ()=>{\n            if (audio) {\n                audio.pause();\n                audio.currentTime = 0; // Reset time\n            // isPlaying state will be updated by the 'pause' event listener\n            }\n        }\n    }[\"useAudio.useCallback[stop]\"], [\n        audio\n    ]);\n    const toggle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAudio.useCallback[toggle]\": async ()=>{\n            if (isPlaying) {\n                pause();\n            } else {\n                // play() already returns a promise and handles errors.\n                // The catch here is mostly for completeness if play() itself threw an unhandled error\n                // before reaching audio.play() (e.g., audio not available).\n                try {\n                    await play();\n                } catch (error) {\n                    console.warn(\"useAudio: Error in toggle (during play attempt):\", error);\n                }\n            }\n        }\n    }[\"useAudio.useCallback[toggle]\"], [\n        isPlaying,\n        pause,\n        play\n    ]);\n    // Return the audio element itself, and the new isReady state\n    return {\n        audio,\n        play,\n        pause,\n        stop,\n        toggle,\n        isPlaying,\n        isReady\n    };\n}\n_s(useAudio, \"bNDjRCCyOhHHOCH3n2etczx3kGc=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZS1hdWRpby50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUV3RDtBQVFqRCxTQUFTRyxTQUFTQyxHQUFXO1FBQUVDLFVBQUFBLGlFQUF3QixDQUFDOztJQUM3RCxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR1AsK0NBQVFBLENBQTBCO0lBQzVELE1BQU0sQ0FBQ1EsV0FBV0MsYUFBYSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUNVLFNBQVNDLFdBQVcsR0FBR1gsK0NBQVFBLENBQUMsT0FBTywwQkFBMEI7O0lBRXhFQyxnREFBU0E7OEJBQUM7WUFDUixtREFBbUQ7WUFDbkQsSUFBSSxJQUE2QixFQUFFO2dCQUNqQyxNQUFNVyxlQUFlLElBQUlDO2dCQUN6QkMsUUFBUUMsR0FBRyxDQUFDLDRDQUFnRCxPQUFKWDtnQkFFeERRLGFBQWFJLE9BQU8sR0FBRyxRQUFRLHdDQUF3QztnQkFFdkUsb0RBQW9EO2dCQUNwRCxJQUFJWCxRQUFRWSxNQUFNLEtBQUtDLFdBQVc7b0JBQ2hDLCtCQUErQjtvQkFDL0JOLGFBQWFLLE1BQU0sR0FBR0UsS0FBS0MsR0FBRyxDQUFDLEdBQUdELEtBQUtFLEdBQUcsQ0FBQyxHQUFHaEIsUUFBUVksTUFBTTtnQkFDOUQ7Z0JBQ0EsSUFBSVosUUFBUWlCLElBQUksS0FBS0osV0FBVztvQkFDOUJOLGFBQWFVLElBQUksR0FBR2pCLFFBQVFpQixJQUFJO2dCQUNsQztnQkFFQSxpQkFBaUI7Z0JBQ2pCLE1BQU1DO3NEQUFjLENBQUNDO3dCQUNuQlYsUUFBUVcsSUFBSSxDQUFDLDZCQUFpQyxPQUFKckIsTUFBT29CO3dCQUNqRGIsV0FBVyxRQUFRLHdDQUF3QztvQkFDN0Q7O2dCQUNBLE1BQU1lOytEQUF1Qjt3QkFDM0JaLFFBQVFDLEdBQUcsQ0FBQyx1QkFBMkIsT0FBSlgsS0FBSTt3QkFDdkNPLFdBQVc7b0JBQ2I7O2dCQUNBLE1BQU1nQjt3REFBZ0I7d0JBQ3BCbEIsYUFB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YTtZQUNwQyxnRUFBZ0U7WUFDbEU7UUFDRjtxQ0FBRztRQUFDckM7S0FBTTtJQUVWLE1BQU1zQyxTQUFTMUMsa0RBQVdBO3dDQUFDO1lBQ3pCLElBQUlNLFdBQVc7Z0JBQ2J1QjtZQUNGLE9BQU87Z0JBQ0wsdURBQXVEO2dCQUN2RCxzRkFBc0Y7Z0JBQ3RGLDREQUE0RDtnQkFDNUQsSUFBSTtvQkFDRixNQUFNRztnQkFDUixFQUFFLE9BQU9FLE9BQU87b0JBQ2R0QixRQUFRVyxJQUFJLENBQUMsb0RBQW9EVztnQkFDbkU7WUFDRjtRQUNGO3VDQUFHO1FBQUM1QjtRQUFXdUI7UUFBT0c7S0FBSztJQUUzQiw2REFBNkQ7SUFDN0QsT0FBTztRQUFFNUI7UUFBTzRCO1FBQU1IO1FBQU9XO1FBQU1FO1FBQVFwQztRQUFXRTtJQUFRO0FBQ2hFO0dBdElnQlAiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGFtZWRcXERlc2t0b3BcXHBvcnRmb2xpb1xcaG9va3NcXHVzZS1hdWRpby50c3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCJcclxuXHJcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCJcclxuXHJcbmludGVyZmFjZSBBdWRpb09wdGlvbnMge1xyXG4gIHZvbHVtZT86IG51bWJlclxyXG4gIGxvb3A/OiBib29sZWFuXHJcbiAgYXV0b3BsYXk/OiBib29sZWFuIC8vIEtlcHQgZm9yIGNvbXBsZXRlbmVzcywgdGhvdWdoIE1MUG9ydGZvbGlvIG1pZ2h0IG92ZXJyaWRlXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBdWRpbyhzcmM6IHN0cmluZywgb3B0aW9uczogQXVkaW9PcHRpb25zID0ge30pIHtcclxuICBjb25zdCBbYXVkaW8sIHNldEF1ZGlvXSA9IHVzZVN0YXRlPEhUTUxBdWRpb0VsZW1lbnQgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbaXNSZWFkeSwgc2V0SXNSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSkgLy8gTmV3IHN0YXRlIGZvciByZWFkaW5lc3NcclxuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIC8vIE9ubHkgY3JlYXRlIGF1ZGlvIGVsZW1lbnQgaW4gYnJvd3NlciBlbnZpcm9ubWVudFxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgY29uc3QgYXVkaW9FbGVtZW50ID0gbmV3IEF1ZGlvKClcclxuICAgICAgY29uc29sZS5sb2coYHVzZUF1ZGlvOiBDcmVhdGluZyBuZXcgQXVkaW8gZWxlbWVudCBmb3IgJHtzcmN9YClcclxuXHJcbiAgICAgIGF1ZGlvRWxlbWVudC5wcmVsb2FkID0gXCJhdXRvXCI7IC8vIEhpbnQgdG8gdGhlIGJyb3dzZXIgdG8gbG9hZCB0aGUgYXVkaW9cclxuXHJcbiAgICAgIC8vIFNldCBwcm9wZXJ0aWVzIGJlZm9yZSBzZXR0aW5nIHNyYyB0byBhdm9pZCBpc3N1ZXNcclxuICAgICAgaWYgKG9wdGlvbnMudm9sdW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBDbGFtcCB2b2x1bWUgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgYXVkaW9FbGVtZW50LnZvbHVtZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG9wdGlvbnMudm9sdW1lKSlcclxuICAgICAgfVxyXG4gICAgICBpZiAob3B0aW9ucy5sb29wICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBhdWRpb0VsZW1lbnQubG9vcCA9IG9wdGlvbnMubG9vcFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFdmVudCBIYW5kbGVyc1xyXG4gICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlOiBFdmVudCkgPT4geyAvLyBIVE1MTWVkaWFFbGVtZW50IGVycm9yIGV2ZW50IGlzIGp1c3QgRXZlbnRcclxuICAgICAgICBjb25zb2xlLndhcm4oYHVzZUF1ZGlvOiBBdWRpbyBlcnJvciBmb3IgJHtzcmN9YCwgZSlcclxuICAgICAgICBzZXRJc1JlYWR5KGZhbHNlKTsgLy8gQXVkaW8gaXMgbm90IHJlYWR5IGlmIGFuIGVycm9yIG9jY3Vyc1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGhhbmRsZUNhblBsYXlUaHJvdWdoID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGB1c2VBdWRpbzogQXVkaW8gZm9yICR7c3JjfSBjYW4gcGxheSB0aHJvdWdoLmApXHJcbiAgICAgICAgc2V0SXNSZWFkeSh0cnVlKVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGhhbmRsZVBsYXlpbmcgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBoYW5kbGVQYXVzZSA9ICgpID0+IHtcclxuICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBoYW5kbGVFbmRlZCA9ICgpID0+IHtcclxuICAgICAgICBpZiAoIWF1ZGlvRWxlbWVudC5sb29wKSB7IC8vIE9ubHkgc2V0IGlzUGxheWluZyB0byBmYWxzZSBpZiBub3QgbG9vcGluZ1xyXG4gICAgICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcblxyXG4gICAgICBhdWRpb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZUVycm9yKVxyXG4gICAgICBhdWRpb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIGhhbmRsZUNhblBsYXlUaHJvdWdoKVxyXG4gICAgICBhdWRpb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgaGFuZGxlUGxheWluZyk7XHJcbiAgICAgIGF1ZGlvRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgaGFuZGxlUGF1c2UpO1xyXG4gICAgICBhdWRpb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIGhhbmRsZUVuZGVkKTtcclxuXHJcblxyXG4gICAgICBhdWRpb0VsZW1lbnQuc3JjID0gc3JjIC8vIFNldCBzb3VyY2UgbGFzdFxyXG4gICAgICBzZXRBdWRpbyhhdWRpb0VsZW1lbnQpIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIHJlLXJlbmRlciB3aGVyZSBob29rIGlzIHVzZWRcclxuXHJcbiAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYHVzZUF1ZGlvOiBDbGVhbmluZyB1cCBBdWRpbyBlbGVtZW50IGZvciAke3NyY31gKVxyXG4gICAgICAgIGF1ZGlvRWxlbWVudC5wYXVzZSgpXHJcbiAgICAgICAgYXVkaW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBoYW5kbGVFcnJvcilcclxuICAgICAgICBhdWRpb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIGhhbmRsZUNhblBsYXlUaHJvdWdoKVxyXG4gICAgICAgIGF1ZGlvRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicGxheWluZ1wiLCBoYW5kbGVQbGF5aW5nKTtcclxuICAgICAgICBhdWRpb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIGhhbmRsZVBhdXNlKTtcclxuICAgICAgICBhdWRpb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIGhhbmRsZUVuZGVkKTtcclxuICAgICAgICBhdWRpb0VsZW1lbnQuc3JjID0gXCJcIiAvLyBSZWxlYXNlIHRoZSByZXNvdXJjZVxyXG4gICAgICAgIHNldEF1ZGlvKG51bGwpICAgICAgLy8gQ2xlYXIgdGhlIGF1ZGlvIGVsZW1lbnQgZnJvbSBzdGF0ZVxyXG4gICAgICAgIHNldElzUmVhZHkoZmFsc2UpICAgLy8gUmVzZXQgcmVhZGluZXNzIHN0YXRlXHJcbiAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKSAvLyBSZXNldCBwbGF5aW5nIHN0YXRlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQgLy8gRm9yIHNlcnZlci1zaWRlIG9yIGlmIHdpbmRvdyBpcyB1bmRlZmluZWRcclxuICB9LCBbc3JjLCBvcHRpb25zLnZvbHVtZSwgb3B0aW9ucy5sb29wXSkgLy8gb3B0aW9ucy5hdXRvcGxheSBoYW5kbGVkIGluIGFub3RoZXIgZWZmZWN0XHJcblxyXG4gIC8vIEF1dG9wbGF5IGVmZmVjdCAtIHdpbGwgYXR0ZW1wdCB0byBwbGF5IGlmIG9wdGlvbnMuYXV0b3BsYXkgaXMgdHJ1ZSBBTkQgYXVkaW8gaXMgcmVhZHlcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKGF1ZGlvICYmIGlzUmVhZHkgJiYgb3B0aW9ucy5hdXRvcGxheSAmJiAhaXNQbGF5aW5nKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGB1c2VBdWRpbzogQXV0b3BsYXkgdHJpZ2dlcmVkIGZvciAke3NyY31gKTtcclxuICAgICAgYXVkaW8ucGxheSgpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAvLyBUaGlzIGNhdGNoIGlzIGZvciBhdXRvcGxheSBhdHRlbXB0cyB3aXRoaW4gdGhlIGhvb2tcclxuICAgICAgICBjb25zb2xlLndhcm4oYHVzZUF1ZGlvOiBBdXRvcGxheSBmb3IgJHtzcmN9IGZhaWxlZC4gQnJvd3NlciBwb2xpY3kgbGlrZWx5IHByZXZlbnRlZCBpdC5gLCBlcnJvcik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFthdWRpbywgaXNSZWFkeSwgb3B0aW9ucy5hdXRvcGxheSwgaXNQbGF5aW5nXSk7IC8vIFJlbW92ZWQgcGxheSBmcm9tIGhlcmUsIGRpcmVjdCBhdWRpby5wbGF5KClcclxuXHJcbiAgY29uc3QgcGxheSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICAgIGlmIChhdWRpbyAmJiBhdWRpby5wYXVzZWQpIHsgLy8gQ2hlY2sgaWYgYXVkaW8gZXhpc3RzIGFuZCBpcyBhY3R1YWxseSBwYXVzZWRcclxuICAgICAgY29uc29sZS5sb2coXCJ1c2VBdWRpbzogcGxheSgpIGNhbGxlZCBieSBjb21wb25lbnRcIik7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgYXVkaW8ucGxheSgpO1xyXG4gICAgICAgIC8vIGlzUGxheWluZyBzdGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYnkgdGhlICdwbGF5aW5nJyBldmVudCBsaXN0ZW5lclxyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcInVzZUF1ZGlvOiBFcnJvciBpbiBwbGF5KCkgY2F1Z2h0OlwiLCBlcnJvcik7XHJcbiAgICAgICAgLy8gaXNQbGF5aW5nIHN0YXRlIHNob3VsZCBiZSBoYW5kbGVkIGJ5ICdwYXVzZScgb3IgJ2Vycm9yJyBsaXN0ZW5lcnMgaWYgcGxheSBmYWlsc1xyXG4gICAgICAgIHRocm93IGVycm9yOyAvLyBSZS10aHJvdyBzbyB0aGUgY2FsbGluZyBjb21wb25lbnQgY2FuIGFsc28gY2F0Y2ggaXRcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChhdWRpbyAmJiAhYXVkaW8ucGF1c2VkKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwidXNlQXVkaW86IHBsYXkoKSBjYWxsZWQsIGJ1dCBhdWRpbyBhbHJlYWR5IHBsYXlpbmcuXCIpO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7IC8vIEluZGljYXRlIHN1Y2Nlc3MgYXMgaXQncyBhbHJlYWR5IHBsYXlpbmdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcInVzZUF1ZGlvOiBwbGF5KCkgY2FsbGVkLCBidXQgYXVkaW8gZWxlbWVudCBpcyBub3QgYXZhaWxhYmxlIG9yIHJlYWR5LlwiKTtcclxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkF1ZGlvIGVsZW1lbnQgbm90IGF2YWlsYWJsZSBvciBub3QgcmVhZHkuXCIpKTtcclxuICAgIH1cclxuICB9LCBbYXVkaW9dKTtcclxuXHJcbiAgY29uc3QgcGF1c2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAoYXVkaW8pIHtcclxuICAgICAgYXVkaW8ucGF1c2UoKTtcclxuICAgICAgLy8gaXNQbGF5aW5nIHN0YXRlIHdpbGwgYmUgdXBkYXRlZCBieSB0aGUgJ3BhdXNlJyBldmVudCBsaXN0ZW5lclxyXG4gICAgfVxyXG4gIH0sIFthdWRpb10pO1xyXG5cclxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKGF1ZGlvKSB7XHJcbiAgICAgIGF1ZGlvLnBhdXNlKCk7XHJcbiAgICAgIGF1ZGlvLmN1cnJlbnRUaW1lID0gMDsgLy8gUmVzZXQgdGltZVxyXG4gICAgICAvLyBpc1BsYXlpbmcgc3RhdGUgd2lsbCBiZSB1cGRhdGVkIGJ5IHRoZSAncGF1c2UnIGV2ZW50IGxpc3RlbmVyXHJcbiAgICB9XHJcbiAgfSwgW2F1ZGlvXSk7XHJcblxyXG4gIGNvbnN0IHRvZ2dsZSA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcclxuICAgIGlmIChpc1BsYXlpbmcpIHtcclxuICAgICAgcGF1c2UoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIHBsYXkoKSBhbHJlYWR5IHJldHVybnMgYSBwcm9taXNlIGFuZCBoYW5kbGVzIGVycm9ycy5cclxuICAgICAgLy8gVGhlIGNhdGNoIGhlcmUgaXMgbW9zdGx5IGZvciBjb21wbGV0ZW5lc3MgaWYgcGxheSgpIGl0c2VsZiB0aHJldyBhbiB1bmhhbmRsZWQgZXJyb3JcclxuICAgICAgLy8gYmVmb3JlIHJlYWNoaW5nIGF1ZGlvLnBsYXkoKSAoZS5nLiwgYXVkaW8gbm90IGF2YWlsYWJsZSkuXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXdhaXQgcGxheSgpO1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcInVzZUF1ZGlvOiBFcnJvciBpbiB0b2dnbGUgKGR1cmluZyBwbGF5IGF0dGVtcHQpOlwiLCBlcnJvcik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbaXNQbGF5aW5nLCBwYXVzZSwgcGxheV0pO1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIGF1ZGlvIGVsZW1lbnQgaXRzZWxmLCBhbmQgdGhlIG5ldyBpc1JlYWR5IHN0YXRlXHJcbiAgcmV0dXJuIHsgYXVkaW8sIHBsYXksIHBhdXNlLCBzdG9wLCB0b2dnbGUsIGlzUGxheWluZywgaXNSZWFkeSB9O1xyXG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VBdWRpbyIsInNyYyIsIm9wdGlvbnMiLCJhdWRpbyIsInNldEF1ZGlvIiwiaXNQbGF5aW5nIiwic2V0SXNQbGF5aW5nIiwiaXNSZWFkeSIsInNldElzUmVhZHkiLCJhdWRpb0VsZW1lbnQiLCJBdWRpbyIsImNvbnNvbGUiLCJsb2ciLCJwcmVsb2FkIiwidm9sdW1lIiwidW5kZWZpbmVkIiwiTWF0aCIsIm1heCIsIm1pbiIsImxvb3AiLCJoYW5kbGVFcnJvciIsImUiLCJ3YXJuIiwiaGFuZGxlQ2FuUGxheVRocm91Z2giLCJoYW5kbGVQbGF5aW5nIiwiaGFuZGxlUGF1c2UiLCJoYW5kbGVFbmRlZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXVzZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhdXRvcGxheSIsInBsYXkiLCJjYXRjaCIsImVycm9yIiwicGF1c2VkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJFcnJvciIsInN0b3AiLCJjdXJyZW50VGltZSIsInRvZ2dsZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/use-audio.tsx\n"));

/***/ })

});